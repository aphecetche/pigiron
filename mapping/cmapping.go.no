package mapping

/*
#cgo CFLAGS: -I/Users/laurent/alice/sw/osx_x86-64/O2/clion-1/include/MCHMappingInterface
 #cgo LDFLAGS: -L/Users/laurent/alice/sw/osx_x86-64/O2/clion-1/lib
 #cgo LDFLAGS: -lMCHMappingImpl3
 #include "SegmentationCInterface.h"
*/
import "C"

import (
	"fmt"
)

type csegmentation struct {
	handle C.MchSegmentationHandle
}

// NewCSegmentation creates a segmentation object for the given detection element plane
func NewCSegmentation(deid int, bending int) (Segmentation, error) {
	d := C.int(deid)
	b := C.int(bending)
	var seg csegmentation
	seg.handle = C.mchSegmentationConstruct(d, b)
	if seg.handle == nil {
		return seg, fmt.Errorf("zob")
	}
	return seg, nil
}

// IsValid returns true is padid is an actual pad in the segmentation
func (seg csegmentation) IsValid(padid int) bool {
	if int(C.mchSegmentationIsPadValid(seg.handle, C.int(padid))) > 0 {
		return true
	}
	return false
}

// FindPadByFEE return the padid of the pad identified by its front-end references(dualSampaID,dualSampaChannel)
func (seg csegmentation) FindPadByFEE(dualSampaID int, dualSampaChannel int) (int, error) {
	padid := C.mchSegmentationFindPadByFEE(seg.handle, C.int(dualSampaID), C.int(dualSampaChannel))
	if seg.IsValid(int(padid)) {
		return int(padid), nil
	}
	return 0, fmt.Errorf("Could not get a pad for dualSampaId %d channel %d", dualSampaID, dualSampaChannel)
}

// FindPadByPosition return the padid of the pad sitting at location (x,y)
func (seg csegmentation) FindPadByPosition(x float64, y float64) (int, error) {
	padid := C.mchSegmentationFindPadByPosition(seg.handle, C.double(x), C.double(y))
	if seg.IsValid(int(padid)) {
		return int(padid), nil
	}
	return 0, fmt.Errorf("Could not get a pad for x %f y %f", x, y)
}
